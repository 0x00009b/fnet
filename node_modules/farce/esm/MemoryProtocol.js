function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import invariant from 'invariant';
import createPath from './createPath';
import ensureLocation from './ensureLocation';
var STATE_KEY = '@@farce/state';

var MemoryProtocol = /*#__PURE__*/function () {
  function MemoryProtocol(initialLocation, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$persistent = _ref.persistent,
        persistent = _ref$persistent === void 0 ? false : _ref$persistent;

    this._persistent = persistent;
    var initialState = persistent ? this._loadState() : null;

    if (initialState) {
      this._stack = initialState.stack;
      this._index = initialState.index;
    } else {
      this._stack = [ensureLocation(initialLocation)];
      this._index = 0;
    }

    this._keyPrefix = Math.random().toString(36).slice(2, 8);
    this._keyIndex = 0;
    this._listener = null;
  }

  var _proto = MemoryProtocol.prototype;

  _proto._loadState = function _loadState() {
    try {
      var _JSON$parse = JSON.parse(window.sessionStorage.getItem(STATE_KEY)),
          stack = _JSON$parse.stack,
          index = _JSON$parse.index; // Check that the stack and index at least seem reasonable before using
      // them as state. This isn't foolproof, but it might prevent mistakes.


      if (Array.isArray(stack) && typeof index === 'number' && stack[index]) {
        return {
          stack: stack,
          index: index
        };
      }
    } catch (e) {} // eslint-disable-line no-empty


    return null;
  };

  _proto.init = function init(delta) {
    if (delta === void 0) {
      delta = 0;
    }

    return _extends({}, this._stack[this._index], {
      action: 'POP',
      index: this._index,
      delta: delta
    });
  };

  _proto.subscribe = function subscribe(listener) {
    var _this = this;

    this._listener = listener;
    return function () {
      _this._listener = null;
    };
  };

  _proto.navigate = function navigate(location) {
    // Match BrowserProtocol here in only saving these fields.
    var action = location.action,
        pathname = location.pathname,
        search = location.search,
        hash = location.hash,
        state = location.state;
    var push = action === 'PUSH';
    !(push || action === 'REPLACE') ? process.env.NODE_ENV !== "production" ? invariant(false, "Unrecognized memory protocol action: %s.", action) : invariant(false) : void 0;
    var delta = push ? 1 : 0;
    this._index += delta;
    var keyIndex = this._keyIndex++;
    var key = this._keyPrefix + ":" + keyIndex.toString(36);
    this._stack[this._index] = {
      pathname: pathname,
      search: search,
      hash: hash,
      state: state,
      key: key
    };

    if (push) {
      this._stack.length = this._index + 1;
    }

    if (this._persistent) {
      this._saveState();
    }

    return _extends({}, location, {
      key: key,
      index: this._index,
      delta: delta
    });
  };

  _proto.go = function go(delta) {
    var prevIndex = this._index;
    this._index = Math.min(Math.max(this._index + delta, 0), this._stack.length - 1);

    if (this._index === prevIndex) {
      return;
    }

    if (this._persistent) {
      this._saveState();
    }

    if (this._listener) {
      this._listener(this.init(this._index - prevIndex));
    }
  };

  _proto._saveState = function _saveState() {
    try {
      window.sessionStorage.setItem(STATE_KEY, JSON.stringify({
        stack: this._stack,
        index: this._index
      }));
    } catch (e) {} // eslint-disable-line no-empty

  };

  _proto.createHref = function createHref(location) {
    return createPath(location);
  };

  return MemoryProtocol;
}();

export { MemoryProtocol as default };