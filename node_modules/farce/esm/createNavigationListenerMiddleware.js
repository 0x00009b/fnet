import isPromise from 'is-promise';
import warning from 'warning';
import ActionTypes from './ActionTypes';
import Actions from './Actions';

function runListenerEntry(_ref, location, callback) {
  var listener = _ref.listener;
  var result;

  try {
    result = listener(location);
  } catch (e) {
    process.env.NODE_ENV !== "production" ? warning(false, 'Ignoring navigation listener `%s` that failed with `%s`.', listener.name, e) : void 0;
    result = null;
  }

  if (!isPromise(result)) {
    return callback(result);
  }

  result["catch"](function (e) {
    process.env.NODE_ENV !== "production" ? warning(false, 'Ignoring navigation listener `%s` that failed with `%s`.', listener.name, e) : void 0;
    return null;
  }).then(callback);
  return undefined;
}

function runListenerEntries(listenerEntries, location, callback) {
  if (!listenerEntries.length) {
    return callback(true);
  }

  return runListenerEntry(listenerEntries[0], location, function (result) {
    return result != null ? callback(result) : runListenerEntries(listenerEntries.slice(1), location, callback);
  });
}

function maybeConfirm(result) {
  if (typeof result === 'boolean') {
    return result;
  }

  return window.confirm(result); // eslint-disable-line no-alert
}

function runAllowNavigation(listenerEntries, location, callback) {
  return runListenerEntries(listenerEntries, location, function (result) {
    return callback(maybeConfirm(result));
  });
}

export default function createNavigationListenerMiddleware() {
  var nextStep = null;
  var listenerEntries = [];
  /* istanbul ignore next: not testable with Karma */

  function onBeforeUnload(event) {
    var syncResult = runListenerEntries(listenerEntries, null, function (result) {
      return result;
    });

    if (syncResult === true || syncResult === undefined) {
      // An asynchronous navigation listener usually means there will be a
      //  custom confirm dialog. However, we'll already be showing the before
      //  unload dialog, and there's no way to prevent the custom dialog from
      //  showing. This is really an error condition in the navigation
      //  listener, but this is the most reasonable thing we can do.
      return undefined;
    }

    var resultSafe = syncResult || '';
    event.preventDefault();
    event.returnValue = resultSafe; // eslint-disable-line no-param-reassign

    return resultSafe;
  }

  function addListener(listener, _temp) {
    var _ref2 = _temp === void 0 ? {} : _temp,
        _ref2$beforeUnload = _ref2.beforeUnload,
        beforeUnload = _ref2$beforeUnload === void 0 ? false : _ref2$beforeUnload;

    // Add the beforeunload event listener only as needed, as its presence
    //  prevents the page from being added to the page navigation cache.
    if (beforeUnload && listenerEntries.every(function (item) {
      return !item.beforeUnload;
    })) {
      window.addEventListener('beforeunload', onBeforeUnload);
    }

    var listenerEntry = {
      listener: listener,
      beforeUnload: beforeUnload
    };
    listenerEntries.push(listenerEntry);
    return function () {
      listenerEntries = listenerEntries.filter(function (item) {
        return item !== listenerEntry;
      });

      if (beforeUnload && listenerEntries.every(function (item) {
        return !item.beforeUnload;
      })) {
        window.removeEventListener('beforeunload', onBeforeUnload);
      }
    };
  }

  function navigationListenerMiddleware(_ref3) {
    var dispatch = _ref3.dispatch;
    return function (next) {
      return function (action) {
        var type = action.type,
            payload = action.payload;

        if (nextStep && type === ActionTypes.UPDATE_LOCATION) {
          var step = nextStep;
          nextStep = null;
          return step(next, action);
        }

        switch (type) {
          case ActionTypes.NAVIGATE:
            return runAllowNavigation(listenerEntries, payload, function (allowNavigation) {
              if (!allowNavigation) {
                return null;
              } // Skip the repeated navigation listener check on
              //  UPDATE_LOCATION.


              nextStep = function nextStep(nextNext, nextAction) {
                return nextNext(nextAction);
              };

              return next(action);
            });

          case ActionTypes.UPDATE_LOCATION:
            {
              // No navigation listeners to run.
              if (!listenerEntries.length) {
                return next(action);
              } // This is the initial load. It doesn't make sense to block this
              //  navigation.


              if (payload.delta === 0) {
                return next(action);
              } // Without delta, we can't restore the location.


              if (payload.delta == null) {
                return runAllowNavigation(listenerEntries, payload, function (allowNavigation) {
                  return allowNavigation ? next(action) : null;
                });
              }

              var finishRunAllowNavigation = function finishRunAllowNavigation(result) {
                if (!maybeConfirm(result)) {
                  return null;
                } // Release the original UPDATE_LOCATION when the un-rewind
                //  happens. We need to do so here to maintain the invariant that
                //  the store location only updates after the window location.


                nextStep = function nextStep() {
                  return next(action);
                };

                dispatch(Actions.go(payload.delta));
                return undefined;
              };

              var sync = true;
              var rewindDone = false;
              var syncResult = runListenerEntries(listenerEntries, payload, function (result) {
                if (sync) {
                  return result;
                }

                if (!rewindDone) {
                  // The rewind hasn't finished yet. Replace the next step listener
                  //  so we finish running when that happens.
                  nextStep = function nextStep() {
                    return finishRunAllowNavigation(result);
                  };

                  return undefined;
                }

                return finishRunAllowNavigation(result);
              });
              sync = false;

              switch (syncResult) {
                case true:
                  // The navigation was synchronously allowed, so skip the rewind.
                  return next(action);

                case false:
                  // We're done as soon as the rewind finishes.
                  nextStep = function nextStep() {};

                  break;

                case undefined:
                  // Let the callback from runListeners take care of things.
                  nextStep = function nextStep() {
                    rewindDone = true;
                  };

                  break;

                default:
                  // Show the confirm dialog after the rewind.
                  nextStep = function nextStep() {
                    return finishRunAllowNavigation(syncResult);
                  };

              }

              dispatch(Actions.go(-payload.delta));
              return undefined;
            }

          case ActionTypes.DISPOSE:
            if (listenerEntries.length > 0 && onBeforeUnload) {
              window.removeEventListener('beforeunload', onBeforeUnload);
            }

            return next(action);

          default:
            return next(action);
        }
      };
    };
  }

  navigationListenerMiddleware.addListener = addListener;
  return navigationListenerMiddleware;
}