"use strict";

exports.__esModule = true;
exports["default"] = void 0;

var _invariant = _interopRequireDefault(require("invariant"));

var _StateStorage = _interopRequireDefault(require("./StateStorage"));

var _createPath = _interopRequireDefault(require("./createPath"));

var _ensureLocation = _interopRequireDefault(require("./ensureLocation"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var HashProtocol = /*#__PURE__*/function () {
  function HashProtocol() {
    this.stateStorage = new _StateStorage["default"](this, '@@farce');
    this._index = null;
    this._numExpectedHashChanges = 0;
  }

  var _proto = HashProtocol.prototype;

  _proto.init = function init() {
    // TODO: Do we still need to work around the old Firefox bug here?
    var location = (0, _ensureLocation["default"])(window.location.hash.slice(1) || '/');

    var _ref = this.stateStorage.read(location, null) || {},
        _ref$index = _ref.index,
        index = _ref$index === void 0 ? 0 : _ref$index,
        state = _ref.state;

    var delta = this._index != null ? index - this._index : 0;
    this._index = index;
    return _extends({
      action: 'POP'
    }, location, {
      index: index,
      delta: delta,
      state: state
    });
  };

  _proto.subscribe = function subscribe(listener) {
    var _this = this;

    var onHashChange = function onHashChange() {
      // Ignore hash change events triggered by our own navigation.
      if (_this._numExpectedHashChanges > 0) {
        --_this._numExpectedHashChanges;
        return;
      }

      listener(_this.init());
    };

    window.addEventListener('hashchange', onHashChange);
    return function () {
      return window.removeEventListener('hashchange', onHashChange);
    };
  };

  _proto.navigate = function navigate(location) {
    var action = location.action,
        state = location.state;
    var push = action === 'PUSH';
    !(push || action === 'REPLACE') ? process.env.NODE_ENV !== "production" ? (0, _invariant["default"])(false, "Unrecognized hash protocol action: %s.", action) : invariant(false) : void 0;
    var delta = push ? 1 : 0;
    this._index += delta;
    var path = (0, _createPath["default"])(location);
    ++this._numExpectedHashChanges;

    if (push) {
      window.location.hash = path;
    } else {
      window.location.replace("#" + path);
    }

    this.stateStorage.save(location, null, {
      index: this._index,
      state: state
    });
    return _extends({}, location, {
      index: this._index,
      delta: delta
    });
  };

  _proto.go = function go(delta) {
    window.history.go(delta);
  };

  _proto.createHref = function createHref(location) {
    return "#" + (0, _createPath["default"])(location);
  };

  return HashProtocol;
}();

exports["default"] = HashProtocol;
module.exports = exports.default;