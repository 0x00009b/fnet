"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

exports.__esModule = true;
exports["default"] = void 0;

var _every = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/every"));

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/index-of"));

var _extends2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/extends"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _entries = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/entries"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array"));

var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));

var _isEqual = _interopRequireDefault(require("lodash/isEqual"));

var _pathToRegexp = _interopRequireDefault(require("path-to-regexp"));

var _warning = _interopRequireDefault(require("warning"));

var Matcher = /*#__PURE__*/function () {
  function Matcher(routeConfig) {
    this.routeConfig = routeConfig; // Overly-aggressive deduplication of packages can lead to the wrong
    // version of path-to-regexp getting bundled. This is a common enough
    // failure mode that it's worthwhile to add a dev-only warning here.

    process.env.NODE_ENV !== "production" ? (0, _warning["default"])(typeof _pathToRegexp["default"].compile === 'function', 'Incorrect version of path-to-regexp imported. If this is running from a client bundle, check your bundler settings.') : void 0;
  }

  var _proto = Matcher.prototype;

  _proto.match = function match(_ref) {
    var pathname = _ref.pathname;
    var matches = this.matchRoutes(this.routeConfig, pathname);

    if (!matches) {
      return null;
    }

    return this.makePayload(matches);
  };

  _proto.getRoutes = function getRoutes(_ref2) {
    var routeIndices = _ref2.routeIndices;

    if (!routeIndices) {
      return null;
    }

    return this.getRoutesFromIndices(routeIndices, this.routeConfig);
  };

  _proto.joinPaths = function joinPaths(basePath, path) {
    if (!path) {
      return basePath;
    }

    if (basePath.charAt(basePath.length - 1) === '/') {
      // eslint-disable-next-line no-param-reassign
      basePath = (0, _slice["default"])(basePath).call(basePath, 0, -1);
    }

    return "" + basePath + this.getCanonicalPattern(path);
  };

  _proto.isActive = function isActive(_ref3, location, _temp) {
    var matchLocation = _ref3.location;

    var _ref4 = _temp === void 0 ? {} : _temp,
        _ref4$exact = _ref4.exact,
        exact = _ref4$exact === void 0 ? false : _ref4$exact;

    return this.isPathnameActive(matchLocation.pathname, location.pathname, exact) && this.isQueryActive(matchLocation.query, location.query);
  };

  _proto.format = function format(pattern, params) {
    return _pathToRegexp["default"].compile(pattern)(params);
  };

  _proto.matchRoutes = function matchRoutes(routeConfig, pathname) {
    for (var index = 0; index < routeConfig.length; ++index) {
      var route = routeConfig[index];
      var match = this.matchRoute(route, pathname);

      if (!match) {
        continue; // eslint-disable-line no-continue
      }

      var params = match.params,
          remaining = match.remaining;
      var children = route.children;

      if (children) {
        if ((0, _isArray["default"])(children)) {
          var childMatches = this.matchRoutes(children, remaining);

          if (childMatches) {
            var _context;

            return (0, _concat["default"])(_context = [{
              index: index,
              params: params
            }]).call(_context, childMatches);
          }
        } else {
          var groups = this.matchGroups(children, remaining);

          if (groups) {
            return [{
              index: index,
              params: params
            }, {
              groups: groups
            }];
          }
        }
      }

      if (!remaining && !children) {
        return [{
          index: index,
          params: params
        }];
      }
    }

    return null;
  };

  _proto.matchRoute = function matchRoute(route, pathname) {
    var routePath = route.path;

    if (!routePath) {
      return {
        params: {},
        remaining: pathname
      };
    }

    var pattern = this.getCanonicalPattern(routePath);
    var keys = [];
    var regexp = (0, _pathToRegexp["default"])(pattern, keys, {
      end: false
    });
    var match = regexp.exec(pathname);

    if (match === null) {
      return null;
    }

    var params = {};
    (0, _forEach["default"])(keys).call(keys, function (_ref5, index) {
      var name = _ref5.name;
      var value = match[index + 1];
      params[name] = value && decodeURIComponent(value);
    });
    return {
      params: params,
      remaining: (0, _slice["default"])(pathname).call(pathname, match[0].length)
    };
  };

  _proto.getCanonicalPattern = function getCanonicalPattern(pattern) {
    return pattern.charAt(0) === '/' ? pattern : "/" + pattern;
  };

  _proto.matchGroups = function matchGroups(routeGroups, pathname) {
    var groups = {};

    for (var _i = 0, _Object$entries = (0, _entries["default"])(routeGroups); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _Object$entries[_i],
          groupName = _Object$entries$_i[0],
          routes = _Object$entries$_i[1];
      var groupMatch = this.matchRoutes(routes, pathname);

      if (!groupMatch) {
        return null;
      }

      groups[groupName] = groupMatch;
    }

    return groups;
  };

  _proto.makePayload = function makePayload(matches) {
    var _this = this,
        _context3,
        _context4;

    var routeMatch = matches[0];

    if (routeMatch.groups) {
      var _context2;

      process.env.NODE_ENV !== "production" ? (0, _warning["default"])(matches.length === 1, 'Route match with groups %s has children, which are ignored.', (0, _keys["default"])(routeMatch.groups).join(', ')) : void 0;
      var groupRouteIndices = {};
      var routeParams = [];
      var _params = {};
      (0, _forEach["default"])(_context2 = (0, _entries["default"])(routeMatch.groups)).call(_context2, function (_ref6) {
        var groupName = _ref6[0],
            groupMatches = _ref6[1];

        var groupPayload = _this.makePayload(groupMatches); // Retain the nested group structure for route indices so we can
        // reconstruct the element tree from flattened route elements.


        groupRouteIndices[groupName] = groupPayload.routeIndices; // Flatten route groups for route params matching getRoutesFromIndices
        // below.

        routeParams.push.apply(routeParams, groupPayload.routeParams); // Just merge all the params depth-first; it's the easiest option.

        (0, _assign["default"])(_params, groupPayload.params);
      });
      return {
        routeIndices: [groupRouteIndices],
        routeParams: routeParams,
        params: _params
      };
    }

    var index = routeMatch.index,
        params = routeMatch.params;

    if (matches.length === 1) {
      return {
        routeIndices: [index],
        routeParams: [params],
        params: params
      };
    }

    var childPayload = this.makePayload((0, _slice["default"])(matches).call(matches, 1));
    return {
      routeIndices: (0, _concat["default"])(_context3 = [index]).call(_context3, childPayload.routeIndices),
      routeParams: (0, _concat["default"])(_context4 = [params]).call(_context4, childPayload.routeParams),
      params: (0, _extends2["default"])({}, params, childPayload.params)
    };
  };

  _proto.getRoutesFromIndices = function getRoutesFromIndices(routeIndices, routeConfigOrGroups) {
    var _this2 = this,
        _context6;

    var routeIndex = routeIndices[0];

    if (typeof routeIndex === 'object') {
      var _context5;

      // Flatten route groups to save resolvers from having to explicitly
      // handle them.
      var groupRoutes = [];
      (0, _forEach["default"])(_context5 = (0, _entries["default"])(routeIndex)).call(_context5, function (_ref7) {
        var groupName = _ref7[0],
            groupRouteIndices = _ref7[1];
        groupRoutes.push.apply(groupRoutes, _this2.getRoutesFromIndices(groupRouteIndices, routeConfigOrGroups[groupName]));
      });
      return groupRoutes;
    }

    var route = routeConfigOrGroups[routeIndex];

    if (routeIndices.length === 1) {
      return [route];
    }

    return (0, _concat["default"])(_context6 = [route]).call(_context6, this.getRoutesFromIndices((0, _slice["default"])(routeIndices).call(routeIndices, 1), route.children));
  };

  _proto.isPathnameActive = function isPathnameActive(matchPathname, pathname, exact) {
    if (pathname === matchPathname) {
      return true;
    }

    if (exact) {
      // The above condition is necessary for an exact match.
      return false;
    } // Require that a partial match be followed by a path separator.


    var pathnameWithSeparator = (0, _slice["default"])(pathname).call(pathname, -1) !== '/' ? pathname + "/" : pathname; // Can't use startsWith, as that requires a polyfill.

    return (0, _indexOf["default"])(matchPathname).call(matchPathname, pathnameWithSeparator) === 0;
  };

  _proto.isQueryActive = function isQueryActive(matchQuery, query) {
    var _context7;

    if (!query) {
      return true;
    }

    return (0, _every["default"])(_context7 = (0, _entries["default"])(query)).call(_context7, function (_ref8) {
      var key = _ref8[0],
          value = _ref8[1];
      return Object.prototype.hasOwnProperty.call(matchQuery, key) ? (0, _isEqual["default"])(matchQuery[key], value) : value === undefined;
    });
  };

  _proto.replaceRouteConfig = function replaceRouteConfig(routeConfig) {
    this.routeConfig = routeConfig;
  };

  return Matcher;
}();

exports["default"] = Matcher;
module.exports = exports.default;