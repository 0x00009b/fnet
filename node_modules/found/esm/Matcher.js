import _everyInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/every";
import _indexOfInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/index-of";
import _extends from "@babel/runtime-corejs3/helpers/esm/extends";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _Object$entries2 from "@babel/runtime-corejs3/core-js-stable/object/entries";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _sliceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/slice";
import isEqual from 'lodash/isEqual';
import pathToRegexp from 'path-to-regexp';
import warning from 'warning';

var Matcher = /*#__PURE__*/function () {
  function Matcher(routeConfig) {
    this.routeConfig = routeConfig; // Overly-aggressive deduplication of packages can lead to the wrong
    // version of path-to-regexp getting bundled. This is a common enough
    // failure mode that it's worthwhile to add a dev-only warning here.

    process.env.NODE_ENV !== "production" ? warning(typeof pathToRegexp.compile === 'function', 'Incorrect version of path-to-regexp imported. If this is running from a client bundle, check your bundler settings.') : void 0;
  }

  var _proto = Matcher.prototype;

  _proto.match = function match(_ref) {
    var pathname = _ref.pathname;
    var matches = this.matchRoutes(this.routeConfig, pathname);

    if (!matches) {
      return null;
    }

    return this.makePayload(matches);
  };

  _proto.getRoutes = function getRoutes(_ref2) {
    var routeIndices = _ref2.routeIndices;

    if (!routeIndices) {
      return null;
    }

    return this.getRoutesFromIndices(routeIndices, this.routeConfig);
  };

  _proto.joinPaths = function joinPaths(basePath, path) {
    if (!path) {
      return basePath;
    }

    if (basePath.charAt(basePath.length - 1) === '/') {
      // eslint-disable-next-line no-param-reassign
      basePath = _sliceInstanceProperty(basePath).call(basePath, 0, -1);
    }

    return "" + basePath + this.getCanonicalPattern(path);
  };

  _proto.isActive = function isActive(_ref3, location, _temp) {
    var matchLocation = _ref3.location;

    var _ref4 = _temp === void 0 ? {} : _temp,
        _ref4$exact = _ref4.exact,
        exact = _ref4$exact === void 0 ? false : _ref4$exact;

    return this.isPathnameActive(matchLocation.pathname, location.pathname, exact) && this.isQueryActive(matchLocation.query, location.query);
  };

  _proto.format = function format(pattern, params) {
    return pathToRegexp.compile(pattern)(params);
  };

  _proto.matchRoutes = function matchRoutes(routeConfig, pathname) {
    for (var index = 0; index < routeConfig.length; ++index) {
      var route = routeConfig[index];
      var match = this.matchRoute(route, pathname);

      if (!match) {
        continue; // eslint-disable-line no-continue
      }

      var params = match.params,
          remaining = match.remaining;
      var children = route.children;

      if (children) {
        if (_Array$isArray(children)) {
          var childMatches = this.matchRoutes(children, remaining);

          if (childMatches) {
            var _context;

            return _concatInstanceProperty(_context = [{
              index: index,
              params: params
            }]).call(_context, childMatches);
          }
        } else {
          var groups = this.matchGroups(children, remaining);

          if (groups) {
            return [{
              index: index,
              params: params
            }, {
              groups: groups
            }];
          }
        }
      }

      if (!remaining && !children) {
        return [{
          index: index,
          params: params
        }];
      }
    }

    return null;
  };

  _proto.matchRoute = function matchRoute(route, pathname) {
    var routePath = route.path;

    if (!routePath) {
      return {
        params: {},
        remaining: pathname
      };
    }

    var pattern = this.getCanonicalPattern(routePath);
    var keys = [];
    var regexp = pathToRegexp(pattern, keys, {
      end: false
    });
    var match = regexp.exec(pathname);

    if (match === null) {
      return null;
    }

    var params = {};

    _forEachInstanceProperty(keys).call(keys, function (_ref5, index) {
      var name = _ref5.name;
      var value = match[index + 1];
      params[name] = value && decodeURIComponent(value);
    });

    return {
      params: params,
      remaining: _sliceInstanceProperty(pathname).call(pathname, match[0].length)
    };
  };

  _proto.getCanonicalPattern = function getCanonicalPattern(pattern) {
    return pattern.charAt(0) === '/' ? pattern : "/" + pattern;
  };

  _proto.matchGroups = function matchGroups(routeGroups, pathname) {
    var groups = {};

    for (var _i = 0, _Object$entries = _Object$entries2(routeGroups); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _Object$entries[_i],
          groupName = _Object$entries$_i[0],
          routes = _Object$entries$_i[1];
      var groupMatch = this.matchRoutes(routes, pathname);

      if (!groupMatch) {
        return null;
      }

      groups[groupName] = groupMatch;
    }

    return groups;
  };

  _proto.makePayload = function makePayload(matches) {
    var _this = this,
        _context3,
        _context4;

    var routeMatch = matches[0];

    if (routeMatch.groups) {
      var _context2;

      process.env.NODE_ENV !== "production" ? warning(matches.length === 1, 'Route match with groups %s has children, which are ignored.', _Object$keys(routeMatch.groups).join(', ')) : void 0;
      var groupRouteIndices = {};
      var routeParams = [];
      var _params = {};

      _forEachInstanceProperty(_context2 = _Object$entries2(routeMatch.groups)).call(_context2, function (_ref6) {
        var groupName = _ref6[0],
            groupMatches = _ref6[1];

        var groupPayload = _this.makePayload(groupMatches); // Retain the nested group structure for route indices so we can
        // reconstruct the element tree from flattened route elements.


        groupRouteIndices[groupName] = groupPayload.routeIndices; // Flatten route groups for route params matching getRoutesFromIndices
        // below.

        routeParams.push.apply(routeParams, groupPayload.routeParams); // Just merge all the params depth-first; it's the easiest option.

        _Object$assign(_params, groupPayload.params);
      });

      return {
        routeIndices: [groupRouteIndices],
        routeParams: routeParams,
        params: _params
      };
    }

    var index = routeMatch.index,
        params = routeMatch.params;

    if (matches.length === 1) {
      return {
        routeIndices: [index],
        routeParams: [params],
        params: params
      };
    }

    var childPayload = this.makePayload(_sliceInstanceProperty(matches).call(matches, 1));
    return {
      routeIndices: _concatInstanceProperty(_context3 = [index]).call(_context3, childPayload.routeIndices),
      routeParams: _concatInstanceProperty(_context4 = [params]).call(_context4, childPayload.routeParams),
      params: _extends({}, params, childPayload.params)
    };
  };

  _proto.getRoutesFromIndices = function getRoutesFromIndices(routeIndices, routeConfigOrGroups) {
    var _this2 = this,
        _context6;

    var routeIndex = routeIndices[0];

    if (typeof routeIndex === 'object') {
      var _context5;

      // Flatten route groups to save resolvers from having to explicitly
      // handle them.
      var groupRoutes = [];

      _forEachInstanceProperty(_context5 = _Object$entries2(routeIndex)).call(_context5, function (_ref7) {
        var groupName = _ref7[0],
            groupRouteIndices = _ref7[1];
        groupRoutes.push.apply(groupRoutes, _this2.getRoutesFromIndices(groupRouteIndices, routeConfigOrGroups[groupName]));
      });

      return groupRoutes;
    }

    var route = routeConfigOrGroups[routeIndex];

    if (routeIndices.length === 1) {
      return [route];
    }

    return _concatInstanceProperty(_context6 = [route]).call(_context6, this.getRoutesFromIndices(_sliceInstanceProperty(routeIndices).call(routeIndices, 1), route.children));
  };

  _proto.isPathnameActive = function isPathnameActive(matchPathname, pathname, exact) {
    if (pathname === matchPathname) {
      return true;
    }

    if (exact) {
      // The above condition is necessary for an exact match.
      return false;
    } // Require that a partial match be followed by a path separator.


    var pathnameWithSeparator = _sliceInstanceProperty(pathname).call(pathname, -1) !== '/' ? pathname + "/" : pathname; // Can't use startsWith, as that requires a polyfill.

    return _indexOfInstanceProperty(matchPathname).call(matchPathname, pathnameWithSeparator) === 0;
  };

  _proto.isQueryActive = function isQueryActive(matchQuery, query) {
    var _context7;

    if (!query) {
      return true;
    }

    return _everyInstanceProperty(_context7 = _Object$entries2(query)).call(_context7, function (_ref8) {
      var key = _ref8[0],
          value = _ref8[1];
      return Object.prototype.hasOwnProperty.call(matchQuery, key) ? isEqual(matchQuery[key], value) : value === undefined;
    });
  };

  _proto.replaceRouteConfig = function replaceRouteConfig(routeConfig) {
    this.routeConfig = routeConfig;
  };

  return Matcher;
}();

export { Matcher as default };