import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/esm/asyncToGenerator";
import _inheritsLoose from "@babel/runtime-corejs3/helpers/esm/inheritsLoose";
import _asyncIterator from "@babel/runtime-corejs3/helpers/esm/asyncIterator";
import mapContextToProps from '@restart/context/mapContextToProps';
import isEqual from 'lodash/isEqual';
import PropTypes from 'prop-types';
import React from 'react';
import { ReactReduxContext } from 'react-redux';
import StaticContainer from 'react-static-container';
import warning from 'warning';
import RouterContext from './RouterContext';
import createRender from './createRender';
import createStoreRouterObject from './createStoreRouterObject';
import resolveRenderArgs from './resolveRenderArgs';
export default function createBaseRouter(_ref) {
  var renderPending = _ref.renderPending,
      renderReady = _ref.renderReady,
      renderError = _ref.renderError,
      _ref$render = _ref.render,
      render = _ref$render === void 0 ? createRender({
    renderPending: renderPending,
    renderReady: renderReady,
    renderError: renderError
  }) : _ref$render;
  var propTypes = {
    store: PropTypes.object.isRequired,
    match: PropTypes.object.isRequired,
    resolvedMatch: PropTypes.object.isRequired,
    matchContext: PropTypes.any,
    resolver: PropTypes.shape({
      resolveElements: PropTypes.func.isRequired
    }).isRequired,
    onResolveMatch: PropTypes.func.isRequired,
    initialRenderArgs: PropTypes.object
  };

  var BaseRouter = /*#__PURE__*/function (_React$Component) {
    _inheritsLoose(BaseRouter, _React$Component);

    function BaseRouter(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;
      var store = props.store,
          match = props.match,
          matchContext = props.matchContext,
          resolver = props.resolver,
          initialRenderArgs = props.initialRenderArgs;
      _this.router = createStoreRouterObject(store);
      _this.state = {
        isInitialRender: true,
        match: match,
        matchContext: matchContext,
        resolver: resolver,
        iteration: 0,
        routerContext: {
          router: _this.router,
          match: initialRenderArgs || null
        },
        element: initialRenderArgs ? render(initialRenderArgs) : null
      };
      _this.mounted = true;
      _this.lastIteration = 0;
      _this.pendingResolvedMatch = false;
      return _this;
    } // We use componentDidMount and componentDidUpdate to resolve the match if
    //  needed because element resolution is asynchronous anyway, and this lets
    //  us not worry about setState not being available in the constructor, or
    //  about having to pass around nextProps.


    var _proto = BaseRouter.prototype;

    _proto.componentDidMount = function componentDidMount() {
      if (!this.props.initialRenderArgs) {
        this.resolveMatch();
      }

      if (process.env.NODE_ENV !== "production" && typeof window !== 'undefined') {
        /* eslint-env browser */

        /* eslint-disable no-underscore-dangle */
        if (window.__FOUND_HOT_RELOAD__) {
          process.env.NODE_ENV !== "production" ? warning(!window.__FOUND_REPLACE_ROUTE_CONFIG__, 'Replacing existing hot reloading hook. Do not render more than one router instance when using hot reloading.') : void 0;
          window.__FOUND_REPLACE_ROUTE_CONFIG__ = this.router.replaceRouteConfig;
        }
        /* eslint-enable no-underscore-dangle */

        /* eslint-env browser: false */

      }
    };

    BaseRouter.getDerivedStateFromProps = function getDerivedStateFromProps(_ref2, state) {
      var match = _ref2.match,
          resolver = _ref2.resolver,
          matchContext = _ref2.matchContext;

      if (state.isInitialRender) {
        return {
          isInitialRender: false
        };
      }

      if (match !== state.match || resolver !== state.resolver || !isEqual(matchContext, state.matchContext)) {
        return {
          match: match,
          resolver: resolver,
          matchContext: matchContext,
          iteration: state.iteration + 1
        };
      }

      return null;
    };

    _proto.componentDidUpdate = function componentDidUpdate() {
      if (this.state.iteration > this.lastIteration) {
        this.lastIteration = this.state.iteration;
        this.resolveMatch();
      }
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.mounted = false;

      if (process.env.NODE_ENV !== "production" && typeof window !== 'undefined') {
        /* eslint-env browser */

        /* eslint-disable no-underscore-dangle */
        if (window.__FOUND_HOT_RELOAD__) {
          delete window.__FOUND_REPLACE_ROUTE_CONFIG__;
        }
        /* eslint-enable no-underscore-dangle */

        /* eslint-env browser: false */

      }
    };

    _proto.resolveMatch = /*#__PURE__*/function () {
      var _resolveMatch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var pendingIteration, pendingMatch, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, renderArgs;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                pendingIteration = this.lastIteration;
                pendingMatch = this.props.match;
                _context.prev = 2;
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _context.prev = 5;
                _iterator = _asyncIterator(resolveRenderArgs(this.router, this.props));

              case 7:
                _context.next = 9;
                return _iterator.next();

              case 9:
                _step = _context.sent;
                _iteratorNormalCompletion = _step.done;
                _context.next = 13;
                return _step.value;

              case 13:
                _value = _context.sent;

                if (_iteratorNormalCompletion) {
                  _context.next = 24;
                  break;
                }

                renderArgs = _value;

                if (!(!this.mounted || this.lastIteration !== pendingIteration)) {
                  _context.next = 18;
                  break;
                }

                return _context.abrupt("return");

              case 18:
                // If we're about to mark the match resolved, delay the rerender
                //  until we do so.
                this.pendingResolvedMatch = !!((renderArgs.elements || renderArgs.error) && this.props.resolvedMatch !== pendingMatch);
                this.setState({
                  routerContext: {
                    router: this.router,
                    match: renderArgs
                  },
                  element: render(renderArgs)
                });

                if (this.pendingResolvedMatch) {
                  // If this is a new match, update the store, so we can rerender at
                  //  the same time as all of the links and other components
                  //  connected to the router state.
                  this.pendingResolvedMatch = false;
                  this.props.onResolveMatch(pendingMatch);
                }

              case 21:
                _iteratorNormalCompletion = true;
                _context.next = 7;
                break;

              case 24:
                _context.next = 30;
                break;

              case 26:
                _context.prev = 26;
                _context.t0 = _context["catch"](5);
                _didIteratorError = true;
                _iteratorError = _context.t0;

              case 30:
                _context.prev = 30;
                _context.prev = 31;

                if (!(!_iteratorNormalCompletion && _iterator["return"] != null)) {
                  _context.next = 35;
                  break;
                }

                _context.next = 35;
                return _iterator["return"]();

              case 35:
                _context.prev = 35;

                if (!_didIteratorError) {
                  _context.next = 38;
                  break;
                }

                throw _iteratorError;

              case 38:
                return _context.finish(35);

              case 39:
                return _context.finish(30);

              case 40:
                _context.next = 50;
                break;

              case 42:
                _context.prev = 42;
                _context.t1 = _context["catch"](2);

                if (!(!this.mounted || this.lastIteration !== pendingIteration)) {
                  _context.next = 46;
                  break;
                }

                return _context.abrupt("return");

              case 46:
                if (!_context.t1.isFoundRedirectException) {
                  _context.next = 49;
                  break;
                }

                this.router.replace(_context.t1.location);
                return _context.abrupt("return");

              case 49:
                throw _context.t1;

              case 50:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[2, 42], [5, 26, 30, 40], [31,, 35, 39]]);
      }));

      function resolveMatch() {
        return _resolveMatch.apply(this, arguments);
      }

      return resolveMatch;
    }();

    _proto.render = function render() {
      var _this$state = this.state,
          iteration = _this$state.iteration,
          routerContext = _this$state.routerContext,
          element = _this$state.element; // Don't rerender synchronously if we have another rerender coming.

      return /*#__PURE__*/React.createElement(StaticContainer, {
        shouldUpdate: this.lastIteration === iteration && !this.pendingResolvedMatch
      }, /*#__PURE__*/React.createElement(RouterContext.Provider, {
        value: routerContext
      }, element));
    };

    return BaseRouter;
  }(React.Component);

  BaseRouter.propTypes = propTypes; // FIXME: For some reason, using contextType doesn't work here.

  return mapContextToProps({
    consumers: ReactReduxContext,
    mapToProps: function mapToProps(_ref3) {
      var store = _ref3.store;
      return {
        store: store
      };
    },
    displayName: 'withStore(BaseRouter)'
  }, BaseRouter);
}