import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/esm/asyncToGenerator";
import FarceActions from 'farce/Actions';
import ServerProtocol from 'farce/ServerProtocol';
import PropTypes from 'prop-types';
import React from 'react';
import { routerShape } from './PropTypes';
import RouterContext from './RouterContext';
import createFarceStore from './createFarceStore';
import createRender from './createRender';
import getStoreRenderArgs from './getStoreRenderArgs';
import defaultResolver from './resolver';
var propTypes = {
  renderArgs: PropTypes.shape({
    router: routerShape.isRequired
  }).isRequired,
  children: PropTypes.node
};

function RouterProvider(_ref) {
  var renderArgs = _ref.renderArgs,
      children = _ref.children;
  return /*#__PURE__*/React.createElement(RouterContext.Provider, {
    value: {
      router: renderArgs.router,
      match: renderArgs
    }
  }, children);
}

RouterProvider.propTypes = propTypes;
export { RouterProvider };
export function getFarceResult(_x) {
  return _getFarceResult.apply(this, arguments);
}

function _getFarceResult() {
  _getFarceResult = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref2) {
    var url, historyMiddlewares, historyOptions, routeConfig, matchContext, _ref2$resolver, resolver, renderPending, renderReady, renderError, _ref2$render, render, store, renderArgs;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            url = _ref2.url, historyMiddlewares = _ref2.historyMiddlewares, historyOptions = _ref2.historyOptions, routeConfig = _ref2.routeConfig, matchContext = _ref2.matchContext, _ref2$resolver = _ref2.resolver, resolver = _ref2$resolver === void 0 ? defaultResolver : _ref2$resolver, renderPending = _ref2.renderPending, renderReady = _ref2.renderReady, renderError = _ref2.renderError, _ref2$render = _ref2.render, render = _ref2$render === void 0 ? createRender({
              renderPending: renderPending,
              renderReady: renderReady,
              renderError: renderError
            }) : _ref2$render;
            store = createFarceStore({
              historyProtocol: new ServerProtocol(url),
              historyMiddlewares: historyMiddlewares,
              historyOptions: historyOptions,
              routeConfig: routeConfig
            });
            _context.prev = 2;
            _context.next = 5;
            return getStoreRenderArgs({
              store: store,
              matchContext: matchContext,
              resolver: resolver
            });

          case 5:
            renderArgs = _context.sent;
            _context.next = 13;
            break;

          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](2);

            if (!_context.t0.isFoundRedirectException) {
              _context.next = 12;
              break;
            }

            return _context.abrupt("return", {
              status: _context.t0.status,
              redirect: {
                url: store.farce.createHref(_context.t0.location)
              }
            });

          case 12:
            throw _context.t0;

          case 13:
            _context.prev = 13;
            // This is a no-op with ServerProtocol, but it doesn't hurt.
            store.dispatch(FarceActions.dispose());
            return _context.finish(13);

          case 16:
            return _context.abrupt("return", {
              status: renderArgs.error ? renderArgs.error.status : 200,
              element: /*#__PURE__*/React.createElement(RouterProvider, {
                renderArgs: renderArgs
              }, render(renderArgs))
            });

          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[2, 8, 13, 16]]);
  }));
  return _getFarceResult.apply(this, arguments);
}