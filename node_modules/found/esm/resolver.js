import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import _everyInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/every";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _someInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/some";
import _awaitAsyncGenerator from "@babel/runtime-corejs3/helpers/esm/awaitAsyncGenerator";
import _wrapAsyncGenerator from "@babel/runtime-corejs3/helpers/esm/wrapAsyncGenerator";
import isPromise from 'is-promise';
import { accumulateRouteValues, checkResolved, getComponents, getRouteMatches, getRouteValue, isResolved } from './ResolverUtils';
import createElements from './createElements';

function getRouteGetData(route) {
  return route.getData;
}

function getRouteData(route) {
  return route.data;
}

export default {
  resolveElements: function resolveElements(match) {
    var _this = this;

    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var routeMatches, Components, data, earlyComponents, earlyData, fetchedComponents, fetchedData, pendingElements;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              routeMatches = getRouteMatches(match);
              Components = getComponents(routeMatches);
              data = _this.getData(match, routeMatches);

              if (!_someInstanceProperty(Components).call(Components, isPromise)) {
                _context.next = 9;
                break;
              }

              _context.next = 6;
              return _awaitAsyncGenerator(_Promise.all(_mapInstanceProperty(Components).call(Components, checkResolved)));

            case 6:
              _context.t0 = _context.sent;
              _context.next = 10;
              break;

            case 9:
              _context.t0 = Components;

            case 10:
              earlyComponents = _context.t0;

              if (!_someInstanceProperty(data).call(data, isPromise)) {
                _context.next = 17;
                break;
              }

              _context.next = 14;
              return _awaitAsyncGenerator(_Promise.all(_mapInstanceProperty(data).call(data, checkResolved)));

            case 14:
              _context.t1 = _context.sent;
              _context.next = 18;
              break;

            case 17:
              _context.t1 = data;

            case 18:
              earlyData = _context.t1;

              if (!(!_everyInstanceProperty(earlyComponents).call(earlyComponents, isResolved) || !_everyInstanceProperty(earlyData).call(earlyData, isResolved))) {
                _context.next = 31;
                break;
              }

              pendingElements = createElements(routeMatches, earlyComponents, earlyData);
              _context.next = 23;
              return _everyInstanceProperty(pendingElements).call(pendingElements, function (element) {
                return element !== undefined;
              }) ? pendingElements : undefined;

            case 23:
              _context.next = 25;
              return _awaitAsyncGenerator(_Promise.all(Components));

            case 25:
              fetchedComponents = _context.sent;
              _context.next = 28;
              return _awaitAsyncGenerator(_Promise.all(data));

            case 28:
              fetchedData = _context.sent;
              _context.next = 33;
              break;

            case 31:
              fetchedComponents = earlyComponents;
              fetchedData = earlyData;

            case 33:
              _context.next = 35;
              return createElements(routeMatches, fetchedComponents, fetchedData);

            case 35:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  },

  /**
   * Generate route data according to their getters, respecting the order of
   * promises per the `defer` flag on routes.
   */
  getData: function getData(match, routeMatches) {
    var _context2;

    return _mapInstanceProperty(_context2 = accumulateRouteValues(routeMatches, match.routeIndices, function (_ref, routeMatch) {
      var _context3;

      var ancestorRouteData = _ref.ancestorRouteData,
          prevParentPromise = _ref.prevParentPromise;
      // For a deferred route, the parent promise is the previous promise.
      // Otherwise, it's the previous parent promise.
      var parentPromise = routeMatch.route.defer ? _Promise.all(ancestorRouteData) : prevParentPromise; // If there is a parent promise, execute after it resolves.

      var routeData = parentPromise ? parentPromise.then(function () {
        return getRouteValue(routeMatch, getRouteGetData, getRouteData);
      }) : getRouteValue(routeMatch, getRouteGetData, getRouteData);
      return {
        routeData: routeData,
        ancestorRouteData: _concatInstanceProperty(_context3 = []).call(_context3, ancestorRouteData, [routeData]),
        prevParentPromise: parentPromise
      };
    }, {
      routeData: null,
      ancestorRouteData: [],
      prevParentPromise: null
    })).call(_context2, function (_ref2) {
      var routeData = _ref2.routeData;
      return routeData;
    });
  }
};